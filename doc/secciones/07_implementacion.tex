\chapter{Implementación}
% La implementación del \emph{software} se ha dividido en hitos. Estos, han sido definidos en Github
% y cada uno de ellos contiene un grupo de \emph{issues} que se corresponden con las distintas
% mejoras que se han ido incorporando al \emph{software} a lo largo de su desarrollo.\\

% Al inicio del proyecto tenía:
% \begin{itemize}
%     \item Una placa Redwire Econotag r3.
%     \item Un BSP para la Econotag.
%     \item Un repositorio de github para el Kernel de FreeRTOS.
%     \item Un repositorio de github para el resto de FreeRTOS.
% \end{itemize}

En este capítulo voy a dar una explicación general del desarrollo del port. Para una explicación más detallada y paso a paso, ver el \autoref{chap:Implementación}. Todo el código está disponible en Github en los repositorios \href{https://github.com/epaubert/FreeRTOS-TFG}{epaubert/FreeRTOS-TFG} y \href{https://github.com/epaubert/FreeRTOS-Kernel-TFG}{epaubert/FreeRTOS-Kernel-TFG}. En concreto el código del port se encuentra en \href{https://github.com/epaubert/FreeRTOS-Kernel-TFG/tree/main/portable/GCC/ARM7_MC13224V}{esta carpeta}, el del BSP en \href{https://github.com/epaubert/FreeRTOS-Kernel-TFG/tree/main/portable/GCC/ARM7_MC13224V/bsp}{esta} y de la demo en \href{https://github.com/epaubert/FreeRTOS-TFG/tree/main/FreeRTOS/Demo/ARM7_MC13224V_GCC}{esta}.
\\

Para entender este proyecto lo vamos a dividir en 4 capas. Estás serán, empezando desde abajo, la Econotag, el BSP, FreeRTOS y las tareas. La figura \ref{fig:capas} muestra las capas y como se conectan entre ellas.

\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{img/capas-impl.png}
\caption{Diagrama por capas del proyecto}
\label{fig:capas}
\end{figure}

\section{La Econotag}

\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{img/econotag-lineas.png}
\caption{Imagen de la Econotag. La zona marcada en azul es la MC13224V, la roja contiene las herramientas de desarrollo}
\label{fig:econotag}
\end{figure}

La primera capa sobre la que construiremos nuestro proyecto será el \emph{hardware}, la placa \emph{Redwire Econotag R3}, o simplemente la Econotag. Es una placa de desarrollo construida alrededor del chip \emph{MC13224V} de Freescale. Esto quiere decir que proporciona herramientas para el desarrollo de proyectos sobre ese chip. En la figura \ref{fig:econotag} se puede ver una imagen de la placa con estas dos partes marcadas.\\

La Econotag cuenta con bastantes capacidades, entre ella destacan un GPIO [\ref{Def:GPIO}], una UART [\ref{Def:UART}] y cuatro \emph{timers} o temporizadores. Además incluye dos botones programables y otro para reiniciar la placa. También contiene el \emph{hardware} necesario para conectarse a redes ZigBee, un tipo de redes utilizadas en domótica principalmente.

A parte del GPIO y la UART, haremos uso de los temporizadores. Estos son cuatro pequeños contadores que pueden programarse para mandar una señal a la unidad central de procesamiento cuando ha pasado un determinado tiempo.

\section{El BSP}
En la asignatura de Sistemas Empotrados se desarrolla un BSP [\ref{Def:BSP}] para la Econotag. Este BSP será la segunda capa de nuestro proyecto. Además de código para que la placa se inicie correctamente, incluye controladores o \emph{drivers} [\ref{Def:driver}] para el GPIO [\ref{Def:GPIO}], la UART [\ref{Def:UART}] y el controlador de interrupciones.

Las \Def{interrupciones} son esenciales para que un computador se sienta fluido hoy en día. Son un mecanismo que permite, como su nombre indica, interrumpir una tarea que está realizando el procesador, ejecutar un pequeño programa, y luego hacer que el procesador vuelva a la tarea que estaba realizando. Los ratones y teclados que utilizan un puerto \emph{PS/2} utilizaban este sistema para responder de manera ágil a las entradas del usuario.\\

Como se indica en la \autoref{fig:capas}, el BSP se comunica la Econotag a través de los \emph{drivers} para acceder a \emph{hardware} específico. Pero este BSP está incompleto. En concreto, para este proyecto, necesito utilizar los temporizadores de la placa.

Por lo tanto, basándome en el manual de la placa \cite{MC1322xRM}, diseñé la estructura que se puede consultar en el Apéndice, \autoref{chap:timer}. Esta estructura simplifica mucho la configuración de los temporizadores ya que a través de ella no es necesario saber direcciones de memoria y máscaras de los registros, solo el temporizador que queremos utilizar.

También creé una función que me permitía configurar uno de los temporizadores cómodamente, entre otras. De esta manera amplié el BSP para que incluyese \emph{drivers} para los temporizadores. Luego modifiqué el código de inicialización de la placa para que se desactivasen todos los temporizadores por defecto. Todo este código fue probado creando un nuevo test en el entorno de desarrollo proporcionado en la asignatura de sistemas empotrados.

Este trabajo está recogido principalmente en los archivos \href{https://github.com/epaubert/FreeRTOS-Kernel-TFG/blob/main/portable/GCC/ARM7_MC13224V/bsp/drivers/timers.c}{timers.c} y \href{https://github.com/epaubert/FreeRTOS-Kernel-TFG/blob/main/portable/GCC/ARM7_MC13224V/bsp/include/timers.h}{timers.h} del BSP que se puede consultar en Github.

\section{FreeRTOS}
Como se ha comentado en las secciones anteriores, FreeRTOS es un RTOS [\ref{Def:RTOS}]. El mecanismo que utiliza este sistema operativo para medir el paso del tiempo son las interrupciones [\ref{Def:interrupciones}] periódicas. Dependiendo de la configuración, FreeRTOS recibirá 10, 100 o hasta 1000 interrupciones por segundo. Estas interrupciones actúan como los \emph{ticks} de un reloj. Al saber cuántos \emph{ticks} han pasado desde que se inició el sistema y a que frecuencia se producen, FreeRTOS puede saber cuánto tiempo ha pasado entre dos instantes.

En la figura \ref{fig:capas} podemos ver que la capa de FreeRTOS se puede dividir en dos subcapas. La superior está compuesta de todas las utilidades generales que contiene FreeRTOS, como la gestión de tareas. Esta capa no va a ser modificada ya que precisamente tiene la funcionalidad que queremos añadir a la Econotag.

La capa inferior es el kérnel o núcleo del sistema operativo. Esta capa es la que será específica de cada \emph{port} y la que debemos modificar para que se comunique con el BSP.\\

Al empezar un \emph{port} de FreeRTOS, se recomienda basarse el \emph{ports} existentes a otra plataforma similar. Yo elegí basarme en el \emph{port} a la familia de placas \emph{LPC2000} dado que está basada en el mismo microprocesador (\emph{ARM7TMDI-S}) que mi placa y no contenía archivos de \emph{drivers} como otros ports. 

Una vez elegido el \emph{port} en el que me baso, hay que cambiar dos cosas importantes. Uno es el medio de generar interrupciones periódicas, y el otro es el de asignar a la interrupción por \emph{software} una función concreta.\\

Para generar estas interrupciones periódicas, utilicé los \emph{drivers} de los temporizadores diseñados en el apartado anterior. En un principio mientras depuraba configuré las interrupciones a 1Hz o una interrupción por segundo, pero más tarde conforme el proyecto avanzaba conseguí que funcionase a 10 y a 100 hercios. En la versión final no funciona correctamente a 1000 Hz, pero esto se debe a que la placa no tiene suficiente capacidad de procesamiento.\\

Las interrupciones por \emph{software} o \emph{SWI} son un tipo de interrupción [\ref{Def:interrupciones}] que se puede utilizar desde un programa para pasar el control al sistema operativo. En el caso de FreeRTOS, cuando una tarea no necesita seguir ejecutándose y puede pasar el control a otra, ejecuta una \emph{SWI} para darle el control al sistema operativo y que este elija la siguiente tarea a ejecutar. Este mecanismo es especialmente importante en sistemas con un solo procesador, como es le caso de la Econotag, ya que permite la ejecución de varias tareas sin que ninguna monopolice el uso del procesador.\\

En este caso, utilicé las herramientas proporcionadas por el BSP para asignar al gestor de las interrupciones por \emph{software} a la función que devuelve el control a FreeRTOS.

\subsection{Problemas con las interrupciones}

\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{img/interrupciones-mal.png}
\caption{Diagrama de la gestión de las interrupciones mal configuradas. Para seguir el proceso, empezar donde el temporizador o una tarea provoca una excepción}
\label{fig:interrupciones-mal}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{img/interrupciones-bien.png}
\caption{Diagrama de la gestión de las interrupciones bien configuradas Para seguir el proceso, empezar donde el temporizador o una tarea provoca una excepción}
\label{fig:interrupciones-bien}
\end{figure}

Estoy utilizando excepciones para manejar tanto en las interrupciones periódicas como las interrupciones por \emph{software}. La principal diferencia entre interrupciones y excepciones es que las interrupciones son externas al procesador mientras que las excepciones son internas. Generalmente cuando se genera una excepción que se puede manejar, se pasa a el controlador de interrupciones. Las excepciones también incluyen el reinicio de la placa o el abortar la ejecución por instrucción o valor inválido.

El BSP tiene unos \emph{drivers} de gestión de interrupciones que guardan el contexto de el programa ejecutándose, mandan ejecutar el programa que corresponda y esperan que ese programa vuelva para restaurar el contexto. El problema es que las funciones de FreeRTOS que se llaman en estos casos también contienen un guardado y restauración de contexto que utiliza para cambiar entre tareas. Por tanto si llamo a estas funciones de FreeRTOS a través del BSP se guardará dos veces el contexto y restaurará una, lo que progresivamente llenará la memoria de la Econotag hasta causar que la placa se cuelgue.\\

Tras mes y medio de tener estos problemas entendí por qué se me colgaba la placa cada cierto tiempo. La forma de solucionar este problema fue saltarme el manejo de interrupciones del BSP, asignando las funciones de FreeRTOS directamente a excepciones. Cuando se produce una excepción por \emph{software}, que normalmente llamaría al controlador del BSP, se llama directamente a la función apropiada de FreeRTOS.\\

En el caso del temporizador, es un poco más complicado. En este tipo de procesadores hay dos rutas para pedir una interrupción, la normal y la rápida, llamadas \emph{IRQ} y \emph{FIQ} respectivamente. Y cada una tiene un tipo de excepción asociado. A través del BSP, cuando ocurre una IRQ se ve de donde viene y se gestiona apropiadamente. Las interrupciones pueden tener muchas utilidades y generarse por causas muy distintas, como puede ser la entrada de datos por el GPIO [\ref{Def:GPIO}] o la UART [\ref{Def:UART}] o por un temporizador por poner varios ejemplos.

Las FIQ se reservan para interrupciones más prioritarias y por eso tienen su propio tipo de excepción, para no pasar por el controlador general. Por tanto utilicé el BSP para que las interrupciones generadas por el temporizador se detectaran como FIQ y asigné el gestor de excepciones de FIQ a la función de las interrupciones periódicas de FreeRTOS.\\

La decisión de utilizar las interrupciones rápidas para los \emph{ticks} de FreeRTOS tiene dos beneficios: el primero es la velocidad, se gestionan más rápido que las interrupciones normales. El segundo es la liberación de las interrupciones normales para otras aplicaciones que puedan requerir de ellas.

\section{Las Tareas}
La última capa, la que podremos apreciar a la vista, serán las tareas. Tras varias revisiones, estará compuesta por tres tareas. Las dos primeras harán parpadear respectivamente los LEDs rojo y verde integrados en la Econotag como parte del GPIO. La tercera irá calculando números de las sucesión de Fibonacci y mostrándolos por pantalla mediante la UART.

\subsection{Tareas de los LEDs}
El diseño de las tareas de los LEDs es muy simple, pero requiere de un trabajo previo. En primer lugar diseñé tres funciones que interactúan con los \emph{drivers} de GPIO en el BSP. El objetivo de estas tres funciones es, respectivamente:
\begin{itemize}
    \item Inicializar los LEDs para que estén disponibles.
    \item Asignar un estado a un LED, encendido o apagado.
    \item Alternar el estado de un LED, de encendido a apagado y viceversa.
\end{itemize}

Una vez programé estas tres funciones, el diseño de una tarea que parpadee un LED es trivial. Una tarea de este tipo consiste en un bucle infinito en el que se realiza la acción deseada y se devuelve el control al sistema operativo.

Por lo tanto creé un bucle que mandaba parpadear un LED y pedía al sistema operativo esperar una determinada cantidad de tiempo. En la versión final la espera depende del LED y la tarea del verde espera el doble que la tarea del rojo.

\subsection{Tarea de Fibonacci}
La tarea de Fibonacci es un poco más complicada. El BSP me proporciona unos \emph{drivers} para mandar caracteres a través de la UART para mostrarlos por un terminal, pero debe de ser una cadena de caracteres. No permite enviarle el número que deseo imprimir directamente.

Por lo tanto el primer paso que realicé fue diseñar una función que, dado un número, lo transformase en una cadena de caracteres. Una vez realizada esta transformación, mandase imprimir mediante los \emph{drivers} de la UART la cadena de caracteres resultante. Antes de enviarse, esta cadena de caracteres  debe de estar terminada por tres caracteres de control para indicar el retorno de linea y el fin de la cadena.\\

En el segundo paso diseñe la función que actúa como tarea. Otra vez consiste de un bucle infinito, pero esta vez se divide en dos partes. La primera llama a la función anterior para imprimir el número de la secuencia de Fibonacci en el que estamos, en el caso de la primera iteración, 1. Una vez realizada la impresión, devuelve el control al sistema operativo para esperar los milisegundos correspondientes al número de la sucesión de Fibonacci

La segunda parte es la que realiza el cálculo de la sucesión. Al guardar los dós números anteriores de la sucesión, es una simple suma cuya eficiencia es O(1). Como transformo el número resultante en una cadena de caracteres, puse una condición que, llegado a cierto número, se reinicia la sucesión. Esto impide que se produzca un desbordamiento al intentar transformar un número demasiado grande. Una vez realizado el cálculo, al igual que en la otra parte de esta tarea, llamo al sistema operativo para esperar los milisegundos correspondientes a la secuencia de Fibonacci.

\subsection{Otras decisiones en el diseño}
FreeRTOS permite asignar distintas prioridades a distintas tareas. Decidí que la tarea con mayor prioridad fuese la de Fibonacci, dado que al terminar las primeras iteraciones, realiza esperas largas donde las otras tareas tienen tiempo de ejecutarse.

